%Version 1 created in 2020 by Kim Davies and Delphine Mossman

%%%%%%%%%%%%%%%%%%%%%%%%%%
% Update log:

% Jan 7, 2021 AZFP Noise Floor Estimate
% Scott Loranger

% 31 August 2021 Far Field Noise Floor removal code
% Modified Nov 19, 2021
% Delphine Mossman

% Version 2 created by Kim Davies
% Oct 4, 2024
% Code clean up and made some pieces more efficient for processing longer
% deployments.

% %% Version 3 (Beta)
% %% Import netcdf file generated by Echopype.  % from this file, we need time, range, Sv
% 
% ncdisp('24090111A.nc')
% Output(1).Date=ncread('24090111A.nc','/Sonar/Beam_group1/ping_time');
% Output(1).Range=(ncread('24090111A.nc','/Sonar/Beam_group1/range_sample')*0.0364)'; % each range bin is 3.64 cm in width
% N = ncread('24090111A.nc','/Sonar/Beam_group1/backscatter_r');
% Output(1).Sv=N(:,:,1)';
% Output(2).Sv=N(:,:,2)';
% Output(3).Sv=N(:,:,3)';
% Output(4).Sv=N(:,:,4)';
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Prepare your workspace and file directories
% clear your workspace
clc
clear variables
close all

% add file paths to code and data files
addpath(genpath('C:/Users/Andrea/Documents/AMesquita2025/UNB/dataAnalysis/preyData/matlab/november2023Code/AZFP Code - 17 Nov 2023/Code'))
addpath(genpath('C:/Users/Andrea/Documents/AMesquita2025/UNB/dataAnalysis/bugsData/azfp'))
addpath(genpath('C:/Users/Andrea/Documents/AMesquita2025/UNB/dataAnalysis/preyData/processedAZFP/updatedCode'))
addpath(genpath('C:/Users/Andrea/Documents/AMesquita2025/UNB/dataAnalysis/preyData/processedAZFP/echopype'))
addpath(genpath('C:/Users/Andrea/Documents/Amesquita2025/UNB/bugsData/azfp/dataQAQC'))


% before starting, you may want to increase the amount of memory that
% MATLAB can use.  Select Home - Preferences - General - Java Heap Memory
% and use the scale bar to increase memory. 
%% AZFP Code from ASL for converting from engineering to real units
% Parameter description and the default value (if the value is omitted):
% >> ParametersAZFP;[Output,Par] = ProcessAZFP(Parameters);
%
% Ver 1.3 September 2017
% written by Dave Billenness
% ASL Environmental Sciences Inc.
% 1-6703 Rajpur Place, Victoria, B.C., V8M 1Z5, Canada
% T: +1 (250) 656-0177 ext. 126
% E: dbillenness@aslenv.com
% w: http://www.aslenv.com/
% For any suggestions, comments, questions or collaboration, please contact me.

% FILE LOADING AND AVERAGING:
% Parameters.ProcDir = 0; 1 will prompt for an entire directory to
% process, = 0 will prompt to load individual files in a directory
Parameters.ProcDir = 1;

% Parameters.datafilename = ''; % '' will prompt for hourly AZFP
% file(s) to load, example '16010100.01A'
Parameters.datafilename = '';

% Parameters.xmlfilename = ''; % prompt for XML filename if no XML file exists
% in the directory, example '15101614.XML'
Parameters.xmlfilename = '';

% Parameters.Salinity = 35; % Salinity in psu
Parameters.Salinity = 33;

% Parameters.Bins2Avg = 10; % number of range bins to average
Parameters.Bins2Avg = 1; % 0.45m ->15

% Parameters.Time2Avg = 60; % number of time values to average
Parameters.Time2Avg = 1; %1

% Parameters.Pressure = 50; % in dbars (~ depth of instrument in meters).
% This can be approximate and is used in the soundspeed and absorption calc
Parameters.Pressure = 100;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PLOTTING:
% Parameters.Plot = 1; % show an echogram plot for each channel
Parameters.Plot = 1;
% Parameters.Channel: freq to plot #1-4, default 1
Parameters.Channel = 1;
% Parameters.Value2Plot = 2; 1,2,3,4 = Counts, Sv, TS, Temperature/Tilts, default 2
Parameters.Value2Plot = 2;

% Parameters.NoiseFloor = 10000; % for Sv and Ts plotting only, values
% with counts < NoiseFloor will be set to -150, can use individual values
% for each frequency, ex. 'NoiseFloor',[10000; 11000; 10500; 12500]
% Default = 10000.
%Parameters.NoiseFloor = [11014;9966;13206;12760]; % AZFP SN 59015
Parameters.NoiseFloor = [12564;9660;13604;10780]; % AZFP SN 59016
% from the manufacturer; 59015/59016 are serial numbers

% Parameters.Orientation = 0 instrument on bottom looking up (range bins), 1 at surface
% looking down (depth bins). This changes the ydir on the echogram plots only. Default is 1.
Parameters.Orientation = 1;

% Parameters.UseTiltCorr = 0; Use the tilt corrected ranges for the echogram plots,
% default 0. Will give a warning if the tilt magnitudes are unreasonable (> 20 deg)
Parameters.UseTiltCorr = 0;

% Load AZFP Data
% Will pull up your file explorer on the current path; first select the
% *folder* with the AZFP data, then select the XML file within that folder
% If there is only one XML file, the code will find it automatically, and
% you will not need to select it
tic
[Output,Par]=ProcessAZFP(Parameters);
toc

%% Davies lab code: sort Output by date
[~,order] = sort([Output(1).Date],'ascend');

Output(1).Date = Output(1).Date(order);
Output(1).BatteryMain = Output(1).BatteryMain(order);
Output(1).BatteryTx = Output(1).BatteryTx(order);
Output(1).Depth = Output(1).Depth(order);

Output(1).N = Output(1).N(order,:);
Output(2).N = Output(2).N(order,:);
Output(3).N = Output(3).N(order,:);
Output(4).N = Output(4).N(order,:);

Output(1).Sv = Output(1).Sv(order,:);
Output(2).Sv = Output(2).Sv(order,:);
Output(3).Sv = Output(3).Sv(order,:);
Output(4).Sv = Output(4).Sv(order,:);

Output(1).TS = Output(1).TS(order,:);
Output(2).TS = Output(2).TS(order,:);
Output(3).TS = Output(3).TS(order,:);
Output(4).TS = Output(4).TS(order,:);

clear order
%% Make a test figure to make sure the data look right
figure(1)
imagesc(Output(4).Sv')
colormap('jet');
caxis([-110 -40]);
xlabel('Ping Number')
ylabel('Range')
h = colorbar;
set(get(h,'label'),'string','Sv (dB scattering per unit volume)');


%% Load in glider data

% load up the raw datafile downloaded from CEOTR
load('/Users/Andrea/Documents/AMesquita2025/UNB/dataAnalysis/preyData/matlab/missions/shad_20240703_196_delayed_a16b_f5fa_83cf.mat');

% put that data into the variable gliderdata
gliderdata = shad_20240703_196_delayed;
clear shad_20240703_196_delayed

% change glider unix time format to same format as in Output file (matlab
% time format)
unix_epoch = datenum(1970,1,1,0,0,0);
gliderdata.time = gliderdata.time./86400 + unix_epoch;

% find the non-NaN indices of glider depth and get their values + the time
% at which they were recorded
nanindex = find(~isnan(gliderdata.depth));
gdepth = gliderdata.depth(nanindex);
gtime = gliderdata.time(nanindex);

%% % During the Baffin Bay 2023 and 2024 missions, it appears that the echosounder was
% pinging even when the glider recorded the AZFP as being powered off.
% This means there will be random pings on the upcast or when the glider is
% transmitting data at the surface.  I need to remove these pings.  Keep
% only pings and time stamps where the glider has recorded that the AZFP is
% on.  Talk to Jude and ASL about this issue.

% First test whether there is a time alignment issue using the indicator that the
% AZFP was on (c_azfp_on).  -1 = off, 0 = on
nanindex2=find(~isnan(gliderdata.c_azfp_on));
azfp_on=gliderdata.c_azfp_on(nanindex2);
azfp_time=gliderdata.time(nanindex2);

figure
scatter(Output(1).Date,zeros(1,length(Output(1).Date)))
hold on
plot(azfp_time,azfp_on)
set(gca,'YLim',[-5 1])
legend('AZFP time stamp per ping','Glider Record of AZFP on/off (c azfp on)','FontSize',20)
datetick

% time align
for ii = 1:length(Output(1).Date)
    [~,timeindex2(ii)] = min(abs(Output(1).Date(ii) - azfp_time));
end
Output(1).azfp_on=azfp_on(timeindex2);
azfpidx=azfp_on(timeindex2);

% remove the pings where the glider says the AZFP should not be on
Output(1).Date = Output(1).Date(azfpidx==0);
Output(1).BatteryMain = Output(1).BatteryMain(azfpidx==0);
Output(1).BatteryTx = Output(1).BatteryTx(azfpidx==0);
Output(1).Depth = Output(1).Depth(azfpidx==0);

Output(1).N = Output(1).N(azfpidx==0,:);
Output(2).N = Output(2).N(azfpidx==0,:);
Output(3).N = Output(3).N(azfpidx==0,:);
Output(4).N = Output(4).N(azfpidx==0,:);

Output(1).Sv = Output(1).Sv(azfpidx==0,:);
Output(2).Sv = Output(2).Sv(azfpidx==0,:);
Output(3).Sv = Output(3).Sv(azfpidx==0,:);
Output(4).Sv = Output(4).Sv(azfpidx==0,:);

Output(1).TS = Output(1).TS(azfpidx==0,:);
Output(2).TS = Output(2).TS(azfpidx==0,:);
Output(3).TS = Output(3).TS(azfpidx==0,:);
Output(4).TS = Output(4).TS(azfpidx==0,:);

%% Standard Sphere Calibration application

% Echosounder 59016 (Davies) calibration offset from standard sphere
% calibration conducted June 2024.  Davies and Mesquita have
% calibration files.
Output(1).Sv(:,:) = Output(1).Sv(:,:) + 0.53;
Output(2).Sv(:,:) = Output(2).Sv(:,:) - 0.80;
Output(3).Sv(:,:) = Output(3).Sv(:,:) + 3.00;
Output(4).Sv(:,:) = Output(4).Sv(:,:) + 6.78;

%% Trim Transmit Pulse and Near Field from Sv data (Step 5 in tutorial)
% Using 1 m as the calculated Rb for the highest frequency (769 kHz) is ~2 m;
% therefore this should eliminate the near-field data from all four
% frequencies
I = find(Output(1).Range(1,:) <= 2);
for i = 1:length(Output)
    Output(i).Sv(:,I) = [];
    Output(i).Range(:,I) = [];
end

% self explanatory, if the ping is within 1 m of the transducer, remove it
% on all frequencies
%% Time - align the glider and AZFP pressure data (Step 2 in tutorial)
% for each date in the echosounder Output file, create a timeindex entry equal to
% the index # of where the minimum difference between each recorded echosounder time
% stamp and every non-NaN glider time stamp is; this is time-aligning the glider and
% echosounder data and assumes no clock drift between glider and AZFP
for ii = 1:length(Output(1).Date)
    [~,timeindex(ii)] = min(abs(Output(1).Date(ii) - gtime));
end

% Create a new variable in the echosounder Output structure called Depth,
% and make it equal to the echosounder Range (i.e. transducer ping depth) plus
% the glider depth at that time
% Then make three more Depths of equal value, so you have one per frequency
Output(1).Depth = Output(1).Range(1,:) + gdepth(timeindex);
Output(2).Depth = Output(1).Depth(:,1:size(Output(2).Sv,2));
Output(3).Depth = Output(1).Depth(:,1:size(Output(3).Sv,2));
Output(4).Depth = Output(1).Depth(:,1:size(Output(4).Sv,2));

%% Remove pings at the surface of the ocean because these often have bubbles in them

% ii=find(Output(1).Depth(:,1)<5)
% Output(1).Depth(ii,:)=[];
% Output(2).Depth(ii,:)=[];
% Output(3).Depth(ii,:)=[];
% Output(4).Depth(ii,:)=[];
% 
%Output(1).Sv(ii,:)=[]; % May 2025:
%Output(2).Sv(ii,:)=[]; % Andréa activated lines 272-277 to match # of elements across matrices
%Output(3).Sv(ii,:)=[];
%Output(4).Sv(ii,:)=[];
% 
%Output(1).Date(ii,:)=[];
shorttime=gdepth(timeindex)
shorttime(ii)=[]; %June 2025: Andréa commented line 279 out (may be causing
%the mistatch in the # of elements) 

% Find the indices of each dive in the AZFP data (part of Step 2 in the tutorial) 
StartDive = find([1;diff(Output(1).Depth(:,1))<-10]);

% find indices where depth decreases. These indices will be used as
% starting points for searching for actual dives.

cc = 0 % number of distinct dives to go into the structure
for DD = 1:length(StartDive)-1
    if (StartDive(DD+1)-1 - StartDive(DD)) > 50
        % This if statement checks the "length" of each dive and only keeps
        % dives with > 250 entries
        % This avoids short dives and "false" dives where the glider begins
        % to rise again at the end of a dive
        % Depending on the depth of the area you are in, this value may
        % need to be changed in order to capture the true dives
        cc = cc+1;
        Dive(cc).Index = [StartDive(DD);StartDive(DD+1)-1];
    end
end
Dive(cc+1).Index = [StartDive(DD+1);length(Output(1).Depth(:,1))] % manual entry of the last dive

% The index-finding code skips over a few data points in between dives,
% which is needed to correct for since glider dives are not separated by time;
% they happen one after the other while the instrument is on
for DD = 1:cc-1
    Dive(DD).Index(2) = Dive(DD + 1).Index(1);
end
Dive(end).Index(2) = length(Output(1).Depth);

%% Far field noise cut off  (Steps 3 and 4 in the tutorial)

% To start getting an idea of where the noise floor cutoff range is
figure
for ii=2:50:2000  % can change to plot more or less data.
    scatter(Output(1).Range(2,:),Output(1).Sv(ii,:),'k') % frequency change line
    % plots range vs frequency-dependent Sv
    hold on
    xlabel('range')
    ylabel('Sv')
end

% For Bay of Fundy, these values are: 130 kHz = 75 m, 200 kHz = 50 m, 455 kHz = 35 m, 769 kHz = 20 m
% these are our "eyeballed" values from the figures
% Remove these depths from the analysis
% For Baffin Bay mission; 15 m on the 130 kHz is all we are getting.
cr = [30,10,10,5];
for i = 1:length(Output) % for each frequency
    J = find(Output(i).Range(1,:) >= cr(i)); % find the frequency-specific
    % far field data
    Output(i).Sv(:,J) = []; % eliminate the Sv in the far field
    Output(i).Range(:,J) = []; % eliminate the far field ranges
    % Redo the depth calculation to account for the far field being cut off
    Output(i).Depth = Output(i).Range(1,:) + shorttime;
    % Output(i).PingDepth = Output(i).Range(1,:) + Output(1).Depth;
end

%% Remove pings at the surface of the ocean because these often have bubbles in them

Output(1).Sv(ii,:)=[]; % May 2025:
Output(2).Sv(ii,:)=[]; % Andréa activated lines 272-277 to match # of elements across matrices
Output(3).Sv(ii,:)=[];
Output(4).Sv(ii,:)=[];
% 
Output(1).Date(ii,:)=[];
shorttime=gdepth(timeindex)
shorttime(ii)=[];

% Find the indices of each dive in the AZFP data (part of Step 2 in the tutorial) 
StartDive = find([1;diff(Output(1).Depth(:,1))<-10]);

cc = 0 % number of distinct dives to go into the structure
for DD = 1:length(StartDive)-1
    if (StartDive(DD+1)-1 - StartDive(DD)) > 50
        cc = cc+1;
        Dive(cc).Index = [StartDive(DD);StartDive(DD+1)-1];
    end
end
Dive(cc+1).Index = [StartDive(DD+1);length(Output(1).Depth(:,1))] % manual entry of the last dive

for DD = 1:cc-1
    Dive(DD).Index(2) = Dive(DD + 1).Index(1);
end
Dive(end).Index(2) = length(Output(1).Depth);

%% Remove seafloor echoes (Step 1 in the tutorial)
% % Find the seafloor indices
tic
for k=1:length(Output) % for each frequency
    %for j = 1:cc % for each dive
    % first need to pull out sv and depths for each dive separately, so
    % remove bottom does not delete too much data
    sv = Output(k).Sv';
    depth = Output(1).Depth';
    % depth = Output(1).PingDepth';
    % next run the find and remove bottom functions to delete all data
    % at or below the seafloor
    [bott_sv, bott_dep, bott_ind] = find_bottom(sv, depth);
    sv_nb = removeBottom(sv,bott_sv,bott_ind);
    % finally, reinsert the data with the seafloor removed into the
    % original Output file
    % Output(k).Sv(Dive(j).Index(1):Dive(j).Index(2),:) = sv_nb';
    Output(k).Sv = sv_nb';
    %end
end
toc

%% Plot Sv for all frequencies to check data length
figure(1)
clf

freqLabels = {'130 kHz', '200 kHz', '455 kHz', '769 kHz'};
Sv_all = {Output(1).Sv, Output(2).Sv, Output(3).Sv, Output(4).Sv};
caxisVals = [-110 -60];

for i = 1:4
    subplot(2,2,i)
    imagesc(Sv_all{i}', 'AlphaData', ~isnan(Sv_all{i}'))
    colormap('jet')
    caxis(caxisVals)
    ylim([0 90])
    xlabel('Ping Number')
    ylabel('Depth (m)')
    title(freqLabels{i})
end

% Shared colorbar
h = colorbar;
ylabel(h, 'Volume Backscatter (dB re 1 m^{-1})')
h.Position(4) = 0.65;
h.Position(1) = .94 - h.Position(3);
h.Position(2) = 0.5 - h.Position(4)/2;


%% remove echoes below the seafloor using 769 kHz matrix

% Above seafloor echoes at 769 kHz
abvSeafloor = size(Output(4).Sv, 2);

% Truncate all other Sv matrices to match the length of 769 kHz
Output(1).Sv = Output(1).Sv(:, 1:abvSeafloor);
Output(2).Sv = Output(2).Sv(:, 1:abvSeafloor);
Output(3).Sv = Output(3).Sv(:, 1:abvSeafloor);
Output(1).Depth = Output(1).Depth(:, 1:abvSeafloor);
Output(2).Depth = Output(2).Depth(:, 1:abvSeafloor);
Output(3).Depth = Output(3).Depth(:, 1:abvSeafloor);

%% Average 10 cm vertical resolution into 1 m depth bins to make the matrices smaller for better storage space
dbins = 1:90;

[m,n]=size(Output(1).Depth)
P(1).avg_sv=NaN(m,90);
P(2).avg_sv=NaN(m,90);
P(3).avg_sv=NaN(m,90);
P(4).avg_sv=NaN(m,90);
tic
for ii=1:length(Output) % for each frequency
    for pp = 1:size(Output(ii).Depth,1); % for each ping
        Xw=10.^(Output(ii).Sv(pp,:)./10); % data
        id=round(Output(ii).Depth(pp,:)); % index
        idx=unique(id);
        mn=accumarray(id',Xw',[],@mean);
        mn(mn==0)=[];
        P(ii).avg_sv(pp,idx)=mn;
        clear id idx mm Xw
    end
    P(ii).avg_sv=P(ii).avg_sv(:,1:90);
end;
toc

%% Organize into separate dives and take the median of all pings at a given depth to create single profiles for each dive (Step 6)

for jj=1:length(Output) % Frequency index
    cc = 0;
    for DD = 1:length(StartDive) % for each index where a dive might start
        if DD == length(StartDive) % important for separation of dives/deal with fact that glider comes back up sometimes
            % we need to check if we are at the end of the StartDive
            % vector, because the code changes
            if (size(P(jj).avg_sv,1) - StartDive(DD)) > 50 % at the end of some dives the glider starts coming back up. Avoid that data. Also avoid very short dives
                cc = cc+1;  % Dive count
                % grab the avg_sv values corresponding to the dive
                Dive(cc).P(jj).sv = P(jj).avg_sv(StartDive(DD):end,:);
                % get the median of the dive avg_sv
                Dive(cc).P(jj).msv = nanmedian(Dive(cc).P(jj).sv,1);
                % use the median not the mean to decrease the influence of high scattering spikes (such as bubbles and fish)
            end
        else % when we are not at the end of the StartDive vector
            if (StartDive(DD+1)-1 - StartDive(DD)) > 50
                cc = cc+1; % Dive count
                % grab the avg_sv values corresponding to the dive
                Dive(cc).P(jj).sv = P(jj).avg_sv(StartDive(DD):StartDive(DD+1)-1,:);
                % get the median of the dive avg_sv
                Dive(cc).P(jj).msv = nanmedian(Dive(cc).P(jj).sv,1);
            end
        end
    end
end

%% Moving average to determine noise floor for each bin (Steps 3 and 4)

% According to Scott, each frequency should have its own noise floor due to
% frequency dependencies, differences in the conditions, etc
% We assume that the minimum Sv in each frequency is equivalent to the
% noise floor for that frequency

d_int = 10;
% depth interval to average over

for i = 1:length(Output) % for each frequency
    % preallocate enough space 
    M(i).AvgSv = nan * ones(size(Dive, 2), length(dbins));
    for f = 1:size(Dive, 2) % for each dive
        % take the mean of d_int Sv values at a time and put them in the M
        % structure
        % any means that include a NaN are set to NaN
        % (need to include the NaNs here for depth window calculations
        % later)
        temp = movmean(Dive(f).P(i).msv, d_int, 'includenan', 'Endpoints','discard');
        M(i).AvgSv(f,1:length(temp)) = temp;

    end
end

% Then find the minimum noise interval for each frequency
for i = 1:length(Output) % for each frequency
    % find the minimum Sv value in the moving average and its index, not
    % counting any NaN values
    [N, index] = min(M(i).AvgSv,[],'all','linear','omitnan');
   
    % raw minimum value
    NoiseFloor(i) = N;
    % dive number for each frequency where the minimum is located
    [D, J] = ind2sub(size(M(i).AvgSv),index);
    divenum(i) = D;
    
    while J >= 187
        J = J - 1;
    end
    
    % depth interval for each frequency where the minimum Sv is located
    DepthWindow(i,:) = dbins(J:J+d_int);
end

% remove the temporary structure
clear temp;

% Subtract the noise floor from the avg_sv structures
for  i = 1:length(Output) % for each frequency
    % subtract the frequency-dependent noise floor from avg_sv
    P(i).avg_sv = P(i).avg_sv - NoiseFloor(i);
end

for j = 1:size(Dive, 2)-1 % for each dive
    for k = 1:length(Output) % for each frequency
        % subtract the frequency-dependent noise floor
        Dive(j).P(k).sv = Dive(j).P(k).sv - NoiseFloor(k);
        % recalculate the median
        Dive(j).P(k).msv = nanmedian(Dive(j).P(k).sv,1);
    end
end

%% % add dive start and end time to each dive
for DD = 1:length(Dive)
    Dive(DD).starttime=Output(1).Date(StartDive(DD));
    Dive(DD).endtime=Output(1).Date(Dive(DD).Index(2));
end


%% db differencing
[m,n]=size(Dive)
for ii=1:n % May 2025: Andréa updated 'm' to 'n' to compute 'Diff' across all dive profiles
Dive(ii).P(1).Diff=real(10*log10(Dive(ii).P(2).sv)) - real(10*log10(Dive(ii).P(1).sv));
Dive(ii).P(2).Diff=real(10*log10(Dive(ii).P(3).sv)) - real(10*log10(Dive(ii).P(2).sv));
Dive(ii).P(3).Diff=real(10*log10(Dive(ii).P(4).sv)) - real(10*log10(Dive(ii).P(3).sv));
end;

%% averaging the db differences per profile
for ii = 1:n % Andréa updated 'm' to 'n' to compute 'mDiff' across all dive profiles
Dive(ii).P(1).mDiff=real(10*log10(nanmedian(10.^(Dive(ii).P(1).Diff)./10)));
Dive(ii).P(2).mDiff=real(10*log10(nanmedian(10.^(Dive(ii).P(2).Diff)./10)));
Dive(ii).P(3).mDiff=real(10*log10(nanmedian(10.^(Dive(ii).P(3).Diff)./10)));
end;

% %% Use this code if you need to merge multiple 'Dive' matrices from
% multiple files.
% 
% filename = strcat("/Users/kimdavies_1/Documents/Science Projects/Active Projects/ArcticGlider_KMC/AZFP/Processed_Data/","2024b.mat");
% save(filename, 'Dive','-v7.3');
% clear filename;
% 
% %% merge multiple structures
% load('2024a.mat')
% Dive1=Dive;
% clear Dive Output
% load('2024b.mat')
% Dive2=Dive;
% clear Dive Output
% 
% % Variable: Dive
% % Convert structures to tables
% aa_t = struct2table( Dive1 );
% bb_t = struct2table( Dive2 );
% % Concatonate tables
% merge_t = [ aa_t ; bb_t ];
% % Convert table to structure
% Dive = table2struct( merge_t )

%% AZFP_Unmasked_Masked_Comparison routine (D. Mossman) - lines 626–750
%  June 2025: Added by Andréa to execute all processing steps in a single run

% First get the dB difference window
% Values below are for copepods between 1.27 and 2.99 mm in length, from
% Joe's spreadsheet

% windows are likely too small; play with these values until the matching
% matrix looks like the patches in the echogram
% 130-200 make 0-7 dB and see if that helps
% ignore 769 kHz for now

% Controlled parameter tuning based on MultiNet data
% Do correlations with windows in 200-455 kHz of 1 dB, 5 dB, 10 dB
% dB_Diff_Lower = [7.4, 13.7, 7.8];
dB_Diff_Lower = [4.1, 6.0, 1.1];
% dB_Diff_Upper = [7.5, 14.2, 8.8];
dB_Diff_Upper = [6.9, 10.7, 2.9];

% is the 455 kHz data "real" or just noise? Calibration issues? Offset or
% dynamic range

% pick a transect, look at the bottom value, see what the values are as a
% pseudo calibration
% if the bottom depth values are off, we will need to do a calibration
% correction; bottom is flat, broad, frequency-independent
% histogram of 1 m above bottom to 2 m below bottom (and right at the bottom)
% for each frequency, see how similar the values are (or how different)
% gives us insight into the sensitivity
% if the dynamic range of the different frequencies is off, this becomes
% trickier

%% Then create the binary filter matrix

% frequency 1 > frequency 2 as a masking matrix, to start (and vice versa)

for i = 1:length(Dive)     % for each dive
    for j = 1:3             % for each frequency difference and dB window
        if isfield(Dive(i).P(j), "Diff") && ~isempty(Dive(i).P(j).Diff)
            dB_Diff = Dive(i).P(j).Diff; %Dive.P.Diff is already in dB space
            Dive(i).P(j).mask = (dB_Diff > dB_Diff_Lower(j)) & (dB_Diff < dB_Diff_Upper(j));
        end
    end
end

% Then multiply masking matrix by Sv to get masked observed Sv

for i = 1:length(Dive)
    Dive(i).P(1).masked = Dive(i).P(1).sv; % 130 kHz is not masked
end

for i = 1:length(Dive)
    for j = 1:3         % for each frequency difference mask
        Dive(i).P(j+1).masked = Dive(i).P(j+1).sv .* Dive(i).P(j).mask;
        Dive(i).P(j+1).masked(Dive(i).P(j+1).masked == 0) = NaN;
    end
end

%% averaging the masked sv per profile (using median instead of mean)

for ii = 1:n
Dive(ii).P(1).mMasked = nanmedian(Dive(ii).P(1).masked);
Dive(ii).P(2).mMasked = nanmedian(Dive(ii).P(2).masked);
Dive(ii).P(3).mMasked = nanmedian(Dive(ii).P(3).masked);
Dive(ii).P(4).mMasked = nanmedian(Dive(ii).P(4).masked);
end;

%% make matrices of each Sv variable

for i=1:length(Dive)
    Sv_130(i,:)=real(10*log10(Dive(i).P(1).msv));
    Sv_200(i,:)=real(10*log10(Dive(i).P(2).msv));
    Sv_455(i,:)=real(10*log10(Dive(i).P(3).msv));
    Sv_769(i,:)=real(10*log10(Dive(i).P(4).msv));
    Sv_200_130(i,:)=Dive(i).P(1).mDiff;
    Sv_455_200(i,:)=Dive(i).P(2).mDiff;
    Sv_769_400(i,:)=Dive(i).P(3).mDiff;
    masked_130(i,:)=real(10*log10(Dive(i).P(1).mMasked));
    masked_200(i,:)=real(10*log10(Dive(i).P(2).mMasked));
    masked_455(i,:)=real(10*log10(Dive(i).P(3).mMasked));
    masked_769(i,:)=real(10*log10(Dive(i).P(4).mMasked));
    StartDiveTime(i,:)=Dive(i).starttime;
    EndDiveTime(i,:)=Dive(i).endtime;
end
Depth=1:90;

%% Plot median Sv for all frequencies
figure(1)
clf

freqLabels = {'130 kHz', '200 kHz', '455 kHz', '769 kHz'};
Sv_all = {Sv_130, Sv_200, Sv_455, Sv_769};
caxisVals = [-110 -60];

for i = 1:4
    subplot(2,2,i)
    imagesc(Sv_all{i}', 'AlphaData', ~isnan(Sv_all{i}'))
    colormap('jet')
    caxis(caxisVals)
    ylim([0 90])
    xlabel('Ping Number')
    ylabel('Depth (m)')
    title(freqLabels{i})
end

% Shared colorbar
h = colorbar;
ylabel(h, 'Volume Backscatter (dB re 1 m^{-1})')
h.Position(4) = 0.65;
h.Position(1) = .94 - h.Position(3);
h.Position(2) = 0.5 - h.Position(4)/2;

% save the figure
filename = strcat("C:/Users/Andrea/Documents/AMesquita2025/UNB/dataAnalysis/preyData/processedAZFP/updatedCode/2024/medianSv2024_1.png");
print(gcf,'-dpng',filename,'-r0')

clear filename;
%close

%% Plot dB differences for all frequencies
figure(1)
clf

diffLabels = {'200-130 kHz', '455-200 kHz', '769-455 kHz'};
dbDiff_all = {Sv_200_130, Sv_455_200, Sv_769_400};
caxisVals = [0 11]

for i = 1:3
    subplot(2,2,i)
    imagesc(dbDiff_all{i}', 'AlphaData', ~isnan(dbDiff_all{i}'))
    colormap('jet')
    caxis(caxisVals)
    xlabel('Ping Number')
    ylabel('Depth (m)')
    title(diffLabels{i})
end

% Shared colorbar
h = colorbar;
ylabel(h, 'dB Difference')
h.Position(4) = 0.65;
h.Position(1) = .94 - h.Position(3);
h.Position(2) = 0.5 - h.Position(4)/2;

% save the figure
filename = strcat("C:/Users/Andrea/Documents/AMesquita2025/UNB/dataAnalysis/preyData/processedAZFP/updatedCode/2024/dbDiff2024_1.png");
print(gcf,'-dpng',filename,'-r0')

clear filename;
%close

%% Plot masked Sv for all frequencies
figure(1)
clf

freqLabels = {'130 kHz', '200 kHz', '455 kHz', '769 kHz'};
Sv_all = {masked_130, masked_200, masked_455, masked_769};
caxisVals = [-110 -60];

for i = 1:4
    subplot(2,2,i)
    imagesc(Sv_all{i}', 'AlphaData', ~isnan(Sv_all{i}'))
    colormap('jet')
    caxis(caxisVals)
    ylim([0 90])
    xlabel('Ping Number')
    ylabel('Depth (m)')
    title(freqLabels{i})
end

% Shared colorbar
h = colorbar;
ylabel(h, 'Volume Backscatter (dB re 1 m^{-1})')
h.Position(4) = 0.65;
h.Position(1) = .94 - h.Position(3);
h.Position(2) = 0.5 - h.Position(4)/2;

% save the figure
filename = strcat("C:/Users/Andrea/Documents/AMesquita2025/UNB/dataAnalysis/preyData/processedAZFP/updatedCode/2024/mMasked2024_1.png");
print(gcf,'-dpng',filename,'-r0')

clear filename;
%close

%% save variables

filename = strcat("C:/Users/Andrea/Documents/AMesquita2025/UNB/dataAnalysis/preyData/processedAZFP/updatedCode/2024/","2024_1_Dive.mat");
save(filename,'Dive','Sv_130','Sv_200','Sv_455','Sv_769','Sv_200_130','Sv_455_200','Sv_769_400','masked_130','masked_200','masked_455','masked_769','StartDiveTime','EndDiveTime','-v7.3');

%%  Test Plots
% Test plot data by profile
figure(1)

subplot(2,1,1)
imagesc([NaN * ones(5, size(P(1).avg_sv, 1)); 10*log10(abs(P(1).avg_sv'))],'AlphaData',~isnan([NaN * ones(5, size(P(1).avg_sv, 1)); 10*log10(abs(P(1).avg_sv'))])) % conversion back to decibels + dealing with the fact that we cut off the first 5 m of data
colormap('jet');
caxis([-100 -70]);
% set(gca, 'Xdir', 'reverse');
xlabel('Time')
ylabel('Depth (m)')
title('130 kHz')
xt = get(gca,'XTick');
xtlbl = [];
for i = 1:numel(xt)
    temp = Output(1).Date(xt(i));
    temp = datetime(temp, 'ConvertFrom','datenum','Format','HH:mm');
    temp = char(temp);
    xtlbl = [xtlbl;temp];
end

set(gca, 'XTick',xt, 'XTickLabel',xtlbl, 'XTickLabelRotation',30)
hold on
%line(1:length(bott_dep2),bott_dep2(1,1:length(bott_dep2)),'Color','r','LineWidth',1)
hold off
colorbar

subplot(2,1,2)
imagesc([NaN * ones(5, size(P(2).avg_sv, 1)); 10*log10(abs(P(2).avg_sv'))],'AlphaData',~isnan([NaN * ones(5, size(P(2).avg_sv, 1)); 10*log10(abs(P(2).avg_sv'))]))
colormap('jet');
caxis([-110 -40]);
% set(gca, 'Xdir', 'reverse');
xlabel('Ping Number')
ylabel('Depth (m)')
ylim([0,90])
title('200 kHz')
set(gca, 'XTick',xt, 'XTickLabel',xtlbl, 'XTickLabelRotation',30)
hold on
%line(1:length(bott_dep2),bott_dep2(2,1:length(bott_dep2)),'Color','r','LineWidth',1)
hold off
colorbar

subplot(2,2,3)
imagesc([NaN * ones(5, size(P(3).avg_sv, 1)); 10*log10(abs(P(3).avg_sv'))],'AlphaData',~isnan([NaN * ones(5, size(P(3).avg_sv, 1)); 10*log10(abs(P(3).avg_sv'))])) 
colormap('jet');
caxis([-80 -40]);
% set(gca, 'Xdir', 'reverse');
xlabel('Ping Number')
ylabel('Depth (m)')
ylim([0,90])
title('455 kHz')
set(gca, 'XTick',xt, 'XTickLabel',xtlbl, 'XTickLabelRotation',30)
hold on
%line(1:length(bott_dep2),bott_dep2(3,1:length(bott_dep2)),'Color','r','LineWidth',1)
hold off

subplot(2,2,4)
imagesc([NaN * ones(5, size(P(4).avg_sv, 1)); 10*log10(abs(P(4).avg_sv'))],'AlphaData',~isnan([NaN * ones(5, size(P(4).avg_sv, 1)); 10*log10(abs(P(4).avg_sv'))]))
caxis([-80 -40]);
% set(gca, 'Xdir', 'reverse');
xlabel('Ping Number')
ylabel('Depth (m)')
ylim([0,90])
title('769 kHz')
set(gca, 'XTick',xt, 'XTickLabel',xtlbl, 'XTickLabelRotation',30)
hold on
%line(1:length(bott_dep2),bott_dep2(4,1:length(bott_dep2)),'Color','r','LineWidth',1)
hold off

% single colorbar for all four plots
h = colorbar;
set(get(h,'label'),'string','Sv (dB scattering per unit volume)');

% h.Position(4) = 0.65;
% h.Position(1) = .94-h.Position(3);
% h.Position(2) = 0.5-h.Position(4)/2;
% 
% AddLetters2Plots(gcf,'VShift',-0.04)
% % save the figure
% filename = strcat("/Users/dmossman/Box/2022 MSc Thesis Work/Visuals/MATLAB Echosounder Figures/",date,"Sept/Frequencies_All_",date,"Sept.png");
% print(gcf,'-dpng',filename,'-r0')
% 
% clear filename;
% %close

%Plot
figure
imagesc(Sv_455')
p=colorbar
ylabel(p,'Volume Backscatter at 769 kHz P2')
caxis([-110 -60])
ylim([0 90])
colormap(jet)

%% Plot a subset of the data - Andréa added this section to QAQC AZFP data

startTimes = datetime(StartDiveTime, 'ConvertFrom', 'datenum');

% Define periods as [month startDay]
periods = [
    7, 21;
    8, 14;
    9,  9
];

for p = 1:size(periods,1)
    month = periods(p, 1);
    startDay = periods(p, 2);

    figure
    for d = 0:2
        thisDay = datetime(2018, month, startDay + d);
        dayMask = isbetween(startTimes, thisDay, thisDay + days(1));
        Sv_day = Sv_455(dayMask, :);

        subplot(2,2,d+1)  % arrange as 2 rows x 2 columns
        imagesc(Sv_day')
        colorbar
        ylabel('Depth (m)')
        xlabel('Dive index (Ping #)')
        title(['Sv at 455 kHz on ', datestr(thisDay, 'mmm dd')])
        caxis([-110 -60])
        ylim([0 90])
        colormap(jet)
    end

    % Add a title for the whole figure
    sgtitle(['Sv at 455 kHz — ', datestr(datetime(2018, month, startDay), 'mmmm'), ...
             ' ', num2str(startDay), '–', num2str(startDay+2)])
end

%% extra plots
%test plot the Sv by dive for the 130 kHz
divedata=[Dive(1).P(1).sv];
for ii=2:length(Dive)
    divedata=[divedata;Dive(ii).P(1).sv];
end;

figure(1)
imagesc([NaN * ones(5, size(divedata, 1)); 10*log10(abs(divedata'))]) % conversion back to decibels + dealing with the fact that we cut off the first 5 m of data
colormap('jet');
caxis([-100 -40]);
xlabel('Ping Number')
ylabel('Depth (m)')
title('130 kHz')
colorbar

% plot single dives
figure
imagesc(10*log10(abs(Dive(6).P(1).sv))')
colormap('jet')
caxis([-80 -60]);
ylim([0 150])