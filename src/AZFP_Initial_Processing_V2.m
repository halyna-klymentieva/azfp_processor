%Version 1 created in 2020 by Kim Davies and Delphine Mossman

%%%%%%%%%%%%%%%%%%%%%%%%%%
% Update log:

% Jan 7, 2021 AZFP Noise Floor Estimate
% Scott Loranger

% 31 August 2021 Far Field Noise Floor removal code
% Modified Nov 19, 2021
% Delphine Mossman

% Version 2 created by Kim Davies
% Oct 4, 2024
% Code clean up and made some pieces more efficient for processing longer
% deployments.

% %% Version 3 (Beta)
% %% Import netcdf file generated by Echopype.  % from this file, we need time, range, Sv

% Output(1).Date=ncread(ncfile,'/Sonar/Beam_group1/ping_time');
% Output(1).Range=(ncread(ncfile,'/Sonar/Beam_group1/range_sample')*0.0364)'; % each range bin is 3.64 cm in width
% %N = ncread(ncfile,'/Sonar/Beam_group1/backscatter_r');
% Output(1).Sv=N(:,:,1)';
% Output(2).Sv=N(:,:,2)';
% Output(3).Sv=N(:,:,3)';
% Output(4).Sv=N(:,:,4)';

% clear your workspace
clc
clear variables
close all

ncfile = 'C:/Users/Andrea/Documents/AMesquita2025/UNB/dataAnalysis/preyData/processedAZFP/echopype/DaleRoach/testsv.nc';
ncdisp(ncfile)

% Read relevant variables
ping_time = ncread(ncfile, 'ping_time');
Sv = ncread(ncfile, 'Sv');
echo_range = ncread(ncfile, 'echo_range');
frequency = ncread(ncfile, 'frequency_nominal');

% Build structure
n = length(frequency);
Output = struct([]);

Output(1).Date = ncread(ncfile, 'ping_time');

for i = 1:n
    Output(i).Range = squeeze(echo_range(:,:,i))';
    Output(i).Sv = squeeze(Sv(:,:,i))';
    Output(i).Freq = frequency(i)/1000;    
end

% Transpose [ping x depth] to [depth x ping]
for ii = 1:4
    Output(ii).Sv = Output(ii).Sv';
    Output(ii).Range = Output(ii).Range';
end

%% Prepare your workspace and file directories

% add file paths to code and data files
addpath(genpath('D:/AZFP_GSL_2025/AZFPCodeAug2025/Code/AzfpMatlabToolbox_v18'))
addpath(genpath('D:/AZFP_GSL_2025/AZFPdata_GSL2025/AZFP_202507'))
addpath(genpath('D:/AZFP_GSL_2025/AZFP_processed_data'))
addpath(genpath('C:/Users/Andrea/Documents/AMesquita2025/UNB/dataAnalysis/preyData/processedAZFP/echopype'))
addpath(genpath('C:/Users/Andrea/Documents/Amesquita2025/UNB/bugsData/azfp/dataQAQC'))

% before starting, you may want to increase the amount of memory that
% MATLAB can use.  Select Home - Preferences - General - Java Heap Memory
% and use the scale bar to increase memory. 
%% AZFP Code from ASL for converting from engineering to real units
% Parameter description and the default value (if the value is omitted):
% >> ParametersAZFP;[Output,Par] = ProcessAZFP(Parameters);
%
% Ver 1.3 September 2017
% written by Dave Billenness
% ASL Environmental Sciences Inc.
% 1-6703 Rajpur Place, Victoria, B.C., V8M 1Z5, Canada
% T: +1 (250) 656-0177 ext. 126
% E: dbillenness@aslenv.com
% w: http://www.aslenv.com/
% For any suggestions, comments, questions or collaboration, please contact me.

% FILE LOADING AND AVERAGING:
% Parameters.ProcDir = 0; 1 will prompt for an entire directory to
% process, = 0 will prompt to load individual files in a directory
Parameters.ProcDir = 1;

% Parameters.datafilename = ''; % '' will prompt for hourly AZFP
% file(s) to load, example '16010100.01A'
Parameters.datafilename = '';

% Parameters.xmlfilename = ''; % prompt for XML filename if no XML file exists
% in the directory, example '15101614.XML'
Parameters.xmlfilename = '';

% Parameters.Salinity = 35; % Salinity in psu
Parameters.Salinity = 33;

% Parameters.Bins2Avg = 10; % number of range bins to average
Parameters.Bins2Avg = 1; % 0.45m ->15

% Parameters.Time2Avg = 60; % number of time values to average
Parameters.Time2Avg = 1; %1

% Parameters.Pressure = 50; % in dbars (~ depth of instrument in meters).
% This can be approximate and is used in the soundspeed and absorption calc
Parameters.Pressure = 100;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PLOTTING:
% Parameters.Plot = 1; % show an echogram plot for each channel
Parameters.Plot = 1;
% Parameters.Channel: freq to plot #1-4, default 1
Parameters.Channel = 1;
% Parameters.Value2Plot = 2; 1,2,3,4 = Counts, Sv, TS, Temperature/Tilts, default 2
Parameters.Value2Plot = 2;

% Parameters.NoiseFloor = 10000; % for Sv and Ts plotting only, values
% with counts < NoiseFloor will be set to -150, can use individual values
% for each frequency, ex. 'NoiseFloor',[10000; 11000; 10500; 12500]
% Default = 10000.
%Parameters.NoiseFloor = [11014;9966;13206;12760]; % AZFP SN 59015
Parameters.NoiseFloor = [12564;9660;13604;10780]; % AZFP SN 59016
% from the manufacturer; 59015/59016 are serial numbers

% Parameters.Orientation = 0 instrument on bottom looking up (range bins), 1 at surface
% looking down (depth bins). This changes the ydir on the echogram plots only. Default is 1.
Parameters.Orientation = 1;

% Parameters.UseTiltCorr = 0; Use the tilt corrected ranges for the echogram plots,
% default 0. Will give a warning if the tilt magnitudes are unreasonable (> 20 deg)
Parameters.UseTiltCorr = 0;

% Load AZFP Data
% Will pull up your file explorer on the current path; first select the
% *folder* with the AZFP data, then select the XML file within that folder
% If there is only one XML file, the code will find it automatically, and
% you will not need to select it
tic
[Output,Par]=ProcessAZFP(Parameters);
toc

%% Davies lab code: sort Output by date
[~,order] = sort([Output(1).Date],'ascend');

Output(1).Date = Output(1).Date(order);
Output(1).BatteryMain = Output(1).BatteryMain(order);
Output(1).BatteryTx = Output(1).BatteryTx(order);
Output(1).Depth = Output(1).Depth(order);

Output(1).N = Output(1).N(order,:);
Output(2).N = Output(2).N(order,:);
Output(3).N = Output(3).N(order,:);
Output(4).N = Output(4).N(order,:);

Output(1).Sv = Output(1).Sv(order,:);
Output(2).Sv = Output(2).Sv(order,:);
Output(3).Sv = Output(3).Sv(order,:);
Output(4).Sv = Output(4).Sv(order,:);

Output(1).TS = Output(1).TS(order,:);
Output(2).TS = Output(2).TS(order,:);
Output(3).TS = Output(3).TS(order,:);
Output(4).TS = Output(4).TS(order,:);

clear order

%% Make a test figure to make sure the data look right
% figure%(1)
% imagesc(Output(3).Sv')
% colormap('jet');
% caxis([-110 -40]);
% xlabel('Ping Number')
% ylabel('Range')
% h = colorbar;
% set(get(h,'label'),'string','Sv (dB scattering per unit volume)');

%% Load in glider data

% load up the raw datafile downloaded from CEOTR
load('/Users/Andrea/Documents/AMesquita2025/UNB/dataAnalysis/preyData/matlab/missions/shad_20230601_168_delayed_merged.mat');

% put that data into the variable gliderdata
gliderdata = shad_20230601_168_delayed;
clear shad_20230601_168_delayed

%PLOT DEPTH AND TIME HERE (CONVERT PING NUMBER TO TIME) TO CHECK GLIDER
%DATA

% change glider unix time format to same format as in Output file (matlab
% time format)
unix_epoch = datenum(1970,1,1,0,0,0);
gliderdata.time = gliderdata.time./86400 + unix_epoch;

% find the non-NaN indices of glider depth and get their values + the time
% at which they were recorded
nanindex = find(~isnan(gliderdata.depth));
gdepth = gliderdata.depth(nanindex);
gtime = gliderdata.time(nanindex);

%% % During the Baffin Bay 2023 and 2024 missions, it appears that the echosounder was
% % pinging even when the glider recorded the AZFP as being powered off.
% % This means there will be random pings on the upcast or when the glider is
% % transmitting data at the surface.  I need to remove these pings.  Keep
% % only pings and time stamps where the glider has recorded that the AZFP is
% % on.  Talk to Jude and ASL about this issue.
% 
% % First test whether there is a time alignment issue using the indicator that the
% % AZFP was on (c_azfp_on).  -1 = off, 0 = on
% nanindex2=find(~isnan(gliderdata.c_azfp_on));
% azfp_on=gliderdata.c_azfp_on(nanindex2);
% azfp_time=gliderdata.time(nanindex2);
% 
% figure
% scatter(Output(1).Date,zeros(1,length(Output(1).Date)))
% hold on
% plot(azfp_time,azfp_on)
% set(gca,'YLim',[-5 1])
% legend('AZFP time stamp per ping','Glider Record of AZFP on/off (c azfp on)','FontSize',20)
% datetick
% 
% % time align
% for ii = 1:length(Output(1).Date)
%     [~,timeindex2(ii)] = min(abs(Output(1).Date(ii) - azfp_time));
% end
% Output(1).azfp_on=azfp_on(timeindex2);
% azfpidx=azfp_on(timeindex2);
% 
% % remove the pings where the glider says the AZFP should not be on
% Output(1).Date = Output(1).Date(azfpidx==0);
% Output(1).BatteryMain = Output(1).BatteryMain(azfpidx==0);
% Output(1).BatteryTx = Output(1).BatteryTx(azfpidx==0);
% Output(1).Depth = Output(1).Depth(azfpidx==0);
% 
% Output(1).N = Output(1).N(azfpidx==0,:);
% Output(2).N = Output(2).N(azfpidx==0,:);
% Output(3).N = Output(3).N(azfpidx==0,:);
% Output(4).N = Output(4).N(azfpidx==0,:);
% 
% Output(1).Sv = Output(1).Sv(azfpidx==0,:);
% Output(2).Sv = Output(2).Sv(azfpidx==0,:);
% Output(3).Sv = Output(3).Sv(azfpidx==0,:);
% Output(4).Sv = Output(4).Sv(azfpidx==0,:);
% 
% Output(1).TS = Output(1).TS(azfpidx==0,:);
% Output(2).TS = Output(2).TS(azfpidx==0,:);
% Output(3).TS = Output(3).TS(azfpidx==0,:);
% Output(4).TS = Output(4).TS(azfpidx==0,:);

%% Standard Sphere Calibration application

% Echosounder 59016 (Davies) calibration offset from standard sphere
% calibration conducted June 2024.  Davies and Mesquita have
% calibration files.
Output(1).Sv(:,:) = Output(1).Sv(:,:) + 1.39;
Output(2).Sv(:,:) = Output(2).Sv(:,:) - 0.69;
Output(3).Sv(:,:) = Output(3).Sv(:,:) + 3.52;
Output(4).Sv(:,:) = Output(4).Sv(:,:) + 5.40;

%% Trim Transmit Pulse and Near Field from Sv data (Step 5 in tutorial)
% Using 1 m as the calculated Rb for the highest frequency (769 kHz) is ~2 m;
% therefore this should eliminate the near-field data from all four
% frequencies
I = find(Output(1).Range(1,:) <= 2);
for i = 1:length(Output)
    Output(i).Sv(:,I) = [];
    Output(i).Range(:,I) = [];
end

% self explanatory, if the ping is within 1 m of the transducer, remove it
% on all frequencies

%% Time - align the glider and AZFP pressure data (Step 2 in tutorial)
% for each date in the echosounder Output file, create a timeindex entry equal to
% the index # of where the minimum difference between each recorded echosounder time
% stamp and every non-NaN glider time stamp is; this is time-aligning the glider and
% echosounder data and assumes no clock drift between glider and AZFP
for ii = 1:length(Output(1).Date)
    [~,timeindex(ii)] = min(abs(Output(1).Date(ii) - gtime));
end

% Create a new variable in the echosounder Output structure called Depth,
% and make it equal to the echosounder Range (i.e. transducer ping depth) plus
% the glider depth at that time
% Then make three more Depths of equal value, so you have one per frequency
Output(1).Depth = Output(1).Range(1,:) + gdepth(timeindex);
Output(2).Depth = Output(1).Depth(:,1:size(Output(2).Sv,2));
Output(3).Depth = Output(1).Depth(:,1:size(Output(3).Sv,2));
Output(4).Depth = Output(1).Depth(:,1:size(Output(4).Sv,2));

%% Remove pings at the surface of the ocean because these often have bubbles in them

% ii=find(Output(1).Depth(:,1)<5)
% Output(1).Depth(ii,:)=[];
% Output(2).Depth(ii,:)=[];
% Output(3).Depth(ii,:)=[];
% Output(4).Depth(ii,:)=[];
% 
%Output(1).Sv(ii,:)=[]; % May 2025:
%Output(2).Sv(ii,:)=[]; % Andréa activated lines 272-277 to match # of elements across matrices
%Output(3).Sv(ii,:)=[]; % Edit: duplicated code (lines 339-365) to run sequentially
%Output(4).Sv(ii,:)=[];
% 
%Output(1).Date(ii,:)=[];
shorttime=gdepth(timeindex)
shorttime(ii)=[]; %June 2025: Andréa commented line 279 out (may be causing
%the mistatch in the # of elements) [haven't got it to work yet]

% Find the indices of each dive in the AZFP data (part of Step 2 in the tutorial) 
StartDive = find([1;diff(Output(1).Depth(:,1))<-10]);

% find indices where depth decreases. These indices will be used as
% starting points for searching for actual dives.

cc = 0 % number of distinct dives to go into the structure
for DD = 1:length(StartDive)-1
    if (StartDive(DD+1)-1 - StartDive(DD)) > 50
        % This if statement checks the "length" of each dive and only keeps
        % dives with > 250 entries
        % This avoids short dives and "false" dives where the glider begins
        % to rise again at the end of a dive
        % Depending on the depth of the area you are in, this value may
        % need to be changed in order to capture the true dives
        cc = cc+1;
        Dive(cc).Index = [StartDive(DD);StartDive(DD+1)-1];
    end
end
Dive(cc+1).Index = [StartDive(DD+1);length(Output(1).Depth(:,1))] % manual entry of the last dive

% The index-finding code skips over a few data points in between dives,
% which is needed to correct for since glider dives are not separated by time;
% they happen one after the other while the instrument is on
for DD = 1:cc-1
    Dive(DD).Index(2) = Dive(DD + 1).Index(1);
end
Dive(end).Index(2) = length(Output(1).Depth);

%% Far field noise cut off  (Steps 3 and 4 in the tutorial)

% To start getting an idea of where the noise floor cutoff range is
% figure
% for ii=2:50:2000  % can change to plot more or less data.
%     scatter(Output(1).Range(2,:),Output(1).Sv(ii,:),'k') % frequency change line
%     % plots range vs frequency-dependent Sv
%     hold on
%     xlabel('range')
%     ylabel('Sv')
% end

% For Bay of Fundy, these values are: 130 kHz = 75 m, 200 kHz = 50 m, 455 kHz = 35 m, 769 kHz = 20 m
% these are our "eyeballed" values from the figures
% Remove these depths from the analysis
% For Baffin Bay mission; 15 m on the 130 kHz is all we are getting.
cr = [30,10,10,5];
for i = 1:length(Output) % for each frequency
    J = find(Output(i).Range(1,:) >= cr(i)); % find the frequency-specific
    % far field data
    Output(i).Sv(:,J) = []; % eliminate the Sv in the far field
    Output(i).Range(:,J) = []; % eliminate the far field ranges
    % Redo the depth calculation to account for the far field being cut off
    Output(i).Depth = Output(i).Range(1,:) + shorttime;
    % Output(i).PingDepth = Output(i).Range(1,:) + Output(1).Depth;
end

%% Remove pings at the surface of the ocean because these often have bubbles in them

Output(1).Sv(ii,:)=[]; % May 2025:
Output(2).Sv(ii,:)=[]; % Andréa activated lines 272-277 to match # of elements across matrices
Output(3).Sv(ii,:)=[];
Output(4).Sv(ii,:)=[];
% 
Output(1).Date(ii,:)=[];
shorttime=gdepth(timeindex)
shorttime(ii)=[];

% Find the indices of each dive in the AZFP data (part of Step 2 in the tutorial) 
StartDive = find([1;diff(Output(1).Depth(:,1))<-10]);

cc = 0 % number of distinct dives to go into the structure
for DD = 1:length(StartDive)-1
    if (StartDive(DD+1)-1 - StartDive(DD)) > 50
        cc = cc+1;
        Dive(cc).Index = [StartDive(DD);StartDive(DD+1)-1];
    end
end
Dive(cc+1).Index = [StartDive(DD+1);length(Output(1).Depth(:,1))] % manual entry of the last dive

for DD = 1:cc-1
    Dive(DD).Index(2) = Dive(DD + 1).Index(1);
end
Dive(end).Index(2) = length(Output(1).Depth);

%% Histogram of Sv data for all frequencies
% figure
% 
% for i = 1:4
%     subplot(2,2,i)
%     sv_data = Output(i).Sv(:);
%     histogram(sv_data, 100, 'Normalization', 'probability')
%     xlabel('Sv (dB)')
%     ylabel('Probability')
%     title(sprintf('%d kHz', Output(i).Freq))
%     grid on
% end

%% Make a histogram of the seafloor data decibel strengths
% % 
% % % Find the seafloor indices
% for k=1:length(Output) % for each frequency
%     % for j = 1:cc % for each dive
%         % first need to pull out sv and depths for each dive separately, so
%         % remove bottom does not delete too much data
%         sv = Output(k).Sv';
%         depth = Output(k).Depth';
%         % depth = Output(k).PingDepth';
%         
%         % next run the find bottom function
%         [bott_sv2(k,:), bott_dep2(k,:), bott_ind2(k,:)] = find_bottom_AM(sv, depth);
%     % end
% end
% 
% figure(1)
% 
% % subplot(2,2,1)
% histogram(bott_sv2(1,:),'BinWidth',1,'FaceAlpha',0.5);
% hold on
% [values, edges] = histcounts(bott_sv2(1,:),'BinWidth', 1);
% centers = (edges(1:end-1)+edges(2:end))/2;
% plot(centers, values,'LineWidth',2)
% % hold off
% % title('130kHz')
% % 
% % subplot(2,2,2)
% histogram(bott_sv2(2,:), 'BinWidth',1,'FaceAlpha',0.5);
% hold on
% [values, edges] = histcounts(bott_sv2(2,:),'BinWidth', 1);
% centers = (edges(1:end-1)+edges(2:end))/2;
% plot(centers, values,'LineWidth',2)
% % hold off
% % title('200kHz')
% % 
% % subplot(2,2,3)
% histogram(bott_sv2(3,:),'BinWidth',1,'FaceAlpha',0.5);
% hold on
% [values, edges] = histcounts(bott_sv2(3,:),'BinWidth', 1);
% centers = (edges(1:end-1)+edges(2:end))/2;
% plot(centers, values,'LineWidth',2)
% % hold off
% % title('455kHz')
% % % 
% % % subplot(2,2,4)
% histogram(bott_sv2(4,:),'BinWidth',1,'FaceAlpha',0.5);
% hold on
% [values, edges] = histcounts(bott_sv2(4,:),'BinWidth', 1);
% centers = (edges(1:end-1)+edges(2:end))/2;
% plot(centers, values,'LineWidth',2)
% % % hold off
% % % title('769kHz')
% % 
% % sgtitle(strcat('Bottom Depth Sv Values (dB) for ',date, ' July 2022'));
% legend({'130 kHz','','200 kHz','','455 kHz','','769 kHz'});
% % 
% % % filename = strcat("/Users/dmossman/Box/2022 MSc Thesis Work/Visuals/MATLAB Echosounder Figures/",date,"Sept/Bott_Sv_Hist_Subplots",date,"Sept.png");
% % % print(gcf,'-dpng',filename,'-r0')
% % % clear filename;

%% Remove all data below a defined depth

for k = 1:length(Output)
    sv_data = Output(k).Sv';
    depth_data = Output(k).Depth';

    dive_mask = false(size(depth_data));

    % Define dives
    for d = 83:83
        idx = Dive(d).Index;

        if isnumeric(idx) && numel(idx) == 2
            ping_start = idx(1);
            ping_end   = idx(2);
        elseif isstruct(idx) && isfield(idx, 'StartPing') && isfield(idx, 'EndPing')
            ping_start = idx.StartPing(1);
            ping_end   = idx.EndPing(1);
        else
            continue
        end

        if ping_end <= size(dive_mask, 2)
            dive_mask(:, ping_start:ping_end) = true;
        end
    end

    % Define depth
    deep_mask = depth_data > 67.5;

    % Combine dive + depth masks
    final_mask = dive_mask & deep_mask;

    % Apply mask
    sv_data(final_mask) = NaN;

    % Store Sv data back in Output
    Output(k).Sv = sv_data';
end

%% Remove seafloor echoes (Step 1 in the tutorial)
% % Find the seafloor indices
tic
for k=1:length(Output) % for each frequency
    %for j = 1:cc % for each dive
    % first need to pull out sv and depths for each dive separately, so
    % remove bottom does not delete too much data
    sv = Output(k).Sv';
    depth = Output(1).Depth';
    % depth = Output(1).PingDepth';
    % next run the find and remove bottom functions to delete all data
    % at or below the seafloor
    [bott_sv, bott_dep, bott_ind] = find_bottom_AM(sv, depth); %June 2025: Andréa updated
    sv_nb = remove_bottom_AM(sv,bott_sv,bott_ind);              %with new code
    % finally, reinsert the data with the seafloor removed into the
    % original Output file
    % Output(k).Sv(Dive(j).Index(1):Dive(j).Index(2),:) = sv_nb';
    Output(k).Sv = sv_nb';
    %end
end
toc

%% Remove residual echoes

for k = 1:length(Output)
    sv_data = Output(k).Sv';
    depth_data = Output(k).Depth';

    % Frequency-specific parameters
    switch k
        case 4 % 769 kHz needs different handling
            depth_range = [50 98];    % Detection zone (m)
            buffer = 16;              % Bins above peak to keep
        otherwise
            depth_range = [50 98];
            buffer = 10;
    end

    % Create ping-level mask only for dives 1–227
    dive_mask = false(1, size(sv_data, 2));
    for d = 1:length(Dive)
        idx = Dive(d).Index;

        if isnumeric(idx) && numel(idx) == 2
            ping_start = idx(1);
            ping_end   = idx(2);
        elseif isstruct(idx) && isfield(idx, 'StartPing') && isfield(idx, 'EndPing')
            ping_start = idx.StartPing(1);
            ping_end   = idx.EndPing(1);
        else
            continue
        end

        % Apply bounds check
        ping_end = min(ping_end, size(sv_data, 2));
        dive_mask(ping_start:ping_end) = true;
    end

    for ping = find(dive_mask)
        sv_col = sv_data(:, ping);
        depth_col = depth_data(:, ping);

        if all(isnan(sv_col)) || max(depth_col) < depth_range(1)
            continue
        end

        % --- STAGE 1: Peak detection within target range ---
        zone_mask = depth_col > depth_range(1) & depth_col < depth_range(2);
        [~, peak_idx] = max(sv_col .* zone_mask);

        % --- STAGE 2: Masking logic ---
        if ~isnan(peak_idx) && sv_col(peak_idx) > -70
            cutoff = min(length(sv_col), peak_idx + buffer);
            sv_col(peak_idx:cutoff) = NaN;
            sv_col(cutoff+1:end) = NaN;
        elseif max(depth_col) > 105
            sv_col(depth_col > 105) = NaN;
        end

        sv_data(:, ping) = sv_col;
    end

    Output(k).Sv = sv_data';
end

%% Remove surface noise

depthMin = 10;   % m
depthMax = 14;  % m

for k = 1:4
    sv_data = Output(k).Sv';
    depth_data = Output(k).Depth';

    for d = 95:length(Dive)
        idx = Dive(d).Index;

        % Get ping range for this dive
        ping_start = idx(1);
        ping_end   = idx(2);

        % Mask depth band
        for ping = ping_start:ping_end
            depth_col = depth_data(:, ping);
            mask_band = depth_col >= depthMin & depth_col <= depthMax;
            sv_data(mask_band, ping) = NaN;
        end
    end

    % Assign back to Output structure
    Output(k).Sv = sv_data';
end

%% Average 10 cm vertical resolution into 1 m depth bins to make the matrices smaller for better storage space
dbins = 1:105;

[m,n]=size(Output(1).Depth)
P(1).avg_sv=NaN(m,105);
P(2).avg_sv=NaN(m,105);
P(3).avg_sv=NaN(m,105);
P(4).avg_sv=NaN(m,105);
tic
for ii=1:length(Output) % for each frequency
    for pp = 1:size(Output(ii).Depth,1); % for each ping
        Xw=10.^(Output(ii).Sv(pp,:)./10); % data
        id=round(Output(ii).Depth(pp,:)); % index
        idx=unique(id);
        mn=accumarray(id',Xw',[],@mean);
        mn(mn==0)=[];                   
        P(ii).avg_sv(pp,idx)=mn;        
        clear id idx mm Xw
    end
    P(ii).avg_sv=P(ii).avg_sv(:,1:105);
end;
toc

%% Organize into separate dives and take the median of all pings at a given depth to create single profiles for each dive (Step 6)

for jj=1:length(Output) % Frequency index
    cc = 0;
    for DD = 1:length(StartDive) % for each index where a dive might start
        if DD == length(StartDive) % important for separation of dives/deal with fact that glider comes back up sometimes
            % we need to check if we are at the end of the StartDive
            % vector, because the code changes
            if (size(P(jj).avg_sv,1) - StartDive(DD)) > 50 % at the end of some dives the glider starts coming back up. Avoid that data. Also avoid very short dives
                cc = cc+1;  % Dive count
                % grab the avg_sv values corresponding to the dive
                Dive(cc).P(jj).sv = P(jj).avg_sv(StartDive(DD):end,:);
                % get the median of the dive avg_sv
                Dive(cc).P(jj).msv = nanmedian(Dive(cc).P(jj).sv,1);
                % use the median not the mean to decrease the influence of high scattering spikes (such as bubbles and fish)
            end
        else % when we are not at the end of the StartDive vector
            if (StartDive(DD+1)-1 - StartDive(DD)) > 50
                cc = cc+1; % Dive count
                % grab the avg_sv values corresponding to the dive
                Dive(cc).P(jj).sv = P(jj).avg_sv(StartDive(DD):StartDive(DD+1)-1,:);
                % get the median of the dive avg_sv
                Dive(cc).P(jj).msv = nanmedian(Dive(cc).P(jj).sv,1);
            end
        end
    end
end

%% Moving average to determine noise floor for each bin (Steps 3 and 4)

% According to Scott, each frequency should have its own noise floor due to
% frequency dependencies, differences in the conditions, etc
% We assume that the minimum Sv in each frequency is equivalent to the
% noise floor for that frequency

d_int = 10;
% depth interval to average over

for i = 1:length(Output) % for each frequency
    % preallocate enough space 
    M(i).AvgSv = nan * ones(size(Dive, 2), length(dbins));
    for f = 1:size(Dive, 2) % for each dive
        % take the mean of d_int Sv values at a time and put them in the M
        % structure
        % any means that include a NaN are set to NaN
        % (need to include the NaNs here for depth window calculations
        % later)
        temp = movmean(Dive(f).P(i).msv, d_int, 'includenan', 'Endpoints','discard');
        M(i).AvgSv(f,1:length(temp)) = temp;

    end
end

% Then find the minimum noise interval for each frequency
for i = 1:length(Output) % for each frequency
    % find the minimum Sv value in the moving average and its index, not
    % counting any NaN values
    [N, index] = min(M(i).AvgSv,[],'all','linear','omitnan');
   
    % raw minimum value
    NoiseFloor(i) = N;
    % dive number for each frequency where the minimum is located
    [D, J] = ind2sub(size(M(i).AvgSv),index);
    divenum(i) = D;
    
    while J >= 187
        J = J - 1;
    end
    
    % depth interval for each frequency where the minimum Sv is located
    DepthWindow(i,:) = dbins(J:J+d_int);
end

% remove the temporary structure
clear temp;

% Subtract the noise floor from the avg_sv structures
for  i = 1:length(Output) % for each frequency
    % subtract the frequency-dependent noise floor from avg_sv
    P(i).avg_sv = P(i).avg_sv - NoiseFloor(i);
end

for j = 1:size(Dive, 2)-1 % for each dive
    for k = 1:length(Output) % for each frequency
        % subtract the frequency-dependent noise floor
        Dive(j).P(k).sv = Dive(j).P(k).sv - NoiseFloor(k);
        % recalculate the median
        Dive(j).P(k).msv = nanmedian(Dive(j).P(k).sv,1);
    end
end

%% % add dive start and end time to each dive
for DD = 1:length(Dive)
    Dive(DD).starttime=Output(1).Date(StartDive(DD));
    Dive(DD).endtime=Output(1).Date(Dive(DD).Index(2));
end

%% db differencing
[m,n]=size(Dive)
for ii=1:n % May 2025: Andréa updated 'm' to 'n' to compute 'Diff' across all dive profiles
Dive(ii).P(1).Diff=real(10*log10(Dive(ii).P(2).sv)) - real(10*log10(Dive(ii).P(1).sv));
Dive(ii).P(2).Diff=real(10*log10(Dive(ii).P(3).sv)) - real(10*log10(Dive(ii).P(2).sv));
Dive(ii).P(3).Diff=real(10*log10(Dive(ii).P(4).sv)) - real(10*log10(Dive(ii).P(3).sv));
end;

%% averaging the db differences per profile
for ii = 1:n % Andréa updated 'm' to 'n' to compute 'mDiff' across all dive profiles
Dive(ii).P(1).mDiff=real(10*log10(nanmedian(10.^((Dive(ii).P(1).Diff)./10))));
Dive(ii).P(2).mDiff=real(10*log10(nanmedian(10.^((Dive(ii).P(2).Diff)./10))));
Dive(ii).P(3).mDiff=real(10*log10(nanmedian(10.^((Dive(ii).P(3).Diff)./10))));
end;

%% AZFP_Unmasked_Masked_Comparison routine (D. Mossman) - lines 626–750
%  June 2025: Added by Andréa to execute all processing steps in a single run

% First get the dB difference window
% Values below are for copepods between 1.27 and 2.99 mm in length, from
% Joe's spreadsheet

% windows are likely too small; play with these values until the matching
% matrix looks like the patches in the echogram
% 130-200 make 0-7 dB and see if that helps
% ignore 769 kHz for now

% Controlled parameter tuning based on MultiNet data
% Do correlations with windows in 200-455 kHz of 1 dB, 5 dB, 10 dB
% dB_Diff_Lower = [7.4, 13.7, 7.8];
dB_Diff_Lower = [5.1, 3.1, -0.8];
% dB_Diff_Upper = [7.5, 14.2, 8.8];
dB_Diff_Upper = [6.6, 8.9, 1.1];

% is the 455 kHz data "real" or just noise? Calibration issues? Offset or
% dynamic range

% pick a transect, look at the bottom value, see what the values are as a
% pseudo calibration
% if the bottom depth values are off, we will need to do a calibration
% correction; bottom is flat, broad, frequency-independent
% histogram of 1 m above bottom to 2 m below bottom (and right at the bottom)
% for each frequency, see how similar the values are (or how different)
% gives us insight into the sensitivity
% if the dynamic range of the different frequencies is off, this becomes
% trickier

%% Create the binary filter matrix

% frequency 1 > frequency 2 as a masking matrix, to start (and vice versa)

for i = 1:length(Dive)     % for each dive
    for j = 1:3             % for each frequency difference and dB window
        %if isfield(Dive(i).P(j), "Diff") && ~isempty(Dive(i).P(j).Diff)
            dB_Diff = Dive(i).P(j).Diff; %Dive.P.Diff is already in dB space
            Dive(i).P(j).mask = (dB_Diff > dB_Diff_Lower(j)) & (dB_Diff < dB_Diff_Upper(j));
        %end
    end
end

% Then multiply masking matrix by Sv to get masked observed Sv

for i = 1:length(Dive)
    Dive(i).P(1).masked = Dive(i).P(1).sv; % 130 kHz is not masked
end

for i = 1:length(Dive)
    for j = 1:3         % for each frequency difference mask
        Dive(i).P(j+1).masked = Dive(i).P(j+1).sv .* Dive(i).P(j).mask;
        Dive(i).P(j+1).masked(Dive(i).P(j+1).masked == 0) = NaN;
    end
end

%% averaging the masked sv per profile (using median instead of mean)

for ii = 1:n
Dive(ii).P(1).mMasked = nanmedian(Dive(ii).P(1).masked);
Dive(ii).P(2).mMasked = nanmedian(Dive(ii).P(2).masked);
Dive(ii).P(3).mMasked = nanmedian(Dive(ii).P(3).masked);
Dive(ii).P(4).mMasked = nanmedian(Dive(ii).P(4).masked);
end;

%% Use this code if you need to merge multiple 'Dive' matrices from multiple files

% %filename = strcat("C:/Users/Andrea/Documents/AMesquita2025/UNB/dataAnalysis/preyData/processedAZFP/updatedCode/2024/","2024_day2_Dive.mat");
% %save(filename, 'Dive','-v7.3');
% %clear filename;
% 
% cd('C:/Users/Andrea/Documents/AMesquita2025/UNB/dataAnalysis/preyData/processedAZFP/updatedCode/2024/entireMission')
% 
% % merge multiple structures
% load('2024_1_Dive.mat')
% Dive1=Dive;
% clear Dive Output
% load('2024_2_Dive.mat')
% Dive2=Dive;
% clear Dive Output
% load('2024_3_Dive.mat')
% Dive3=Dive;
% clear Dive Output
% load('2024_4_Dive.mat')
% Dive4=Dive;
% clear Dive Output
% 
% % Variable: Dive
% % Convert structures to tables
% aa_t = struct2table( Dive1 );
% bb_t = struct2table( Dive2 );
% cc_t = struct2table( Dive3 );
% dd_t = struct2table( Dive4 );
% % Concatonate tables
% merge_t = [ aa_t ; bb_t ; cc_t ; dd_t ];
% % Convert table to structure
% Dive = table2struct( merge_t )

%% make matrices of each Sv variable

for i=1:length(Dive)
    Sv_130(i,:)=real(10*log10(Dive(i).P(1).msv));
    Sv_200(i,:)=real(10*log10(Dive(i).P(2).msv));
    Sv_455(i,:)=real(10*log10(Dive(i).P(3).msv));
    Sv_769(i,:)=real(10*log10(Dive(i).P(4).msv));
    Sv_200_130(i,:)=Dive(i).P(1).mDiff;
    Sv_455_200(i,:)=Dive(i).P(2).mDiff;
    Sv_769_400(i,:)=Dive(i).P(3).mDiff;
    masked_130(i,:)=real(10*log10(Dive(i).P(1).mMasked));
    masked_200(i,:)=real(10*log10(Dive(i).P(2).mMasked));
    masked_455(i,:)=real(10*log10(Dive(i).P(3).mMasked));
    masked_769(i,:)=real(10*log10(Dive(i).P(4).mMasked));
    StartDiveTime(i,:)=Dive(i).starttime;
    EndDiveTime(i,:)=Dive(i).endtime;
end
Depth=1:105;

%% mask echoes below the seafloor using 769 kHz matrix (or masked 455 kHz)

% idx = NaN(size(masked_455, 1), 1);
% 
% for i = 1:size(masked_455, 1)
%     rowData = masked_455(i, :);
% 
%     for j = size(rowData, 2):-1:1
%         if ~isnan(rowData(j))
%             idx(i) = j;
%             break;
%         end
%     end
% end
% 
% % Mask values below the seafloor (after the last valid bin)
% for i = 1:size(Sv_130, 1)
%     colStart = idx(i) + 1;
%     if ~isnan(colStart) && colStart <= size(Sv_130, 2)
%         Sv_130(i, colStart:end)     = NaN;
%         Sv_200(i, colStart:end)     = NaN;
%         Sv_455(i, colStart:end)     = NaN;
%         Sv_200_130(i, colStart:end) = NaN;
%         Sv_455_200(i, colStart:end) = NaN;
%         masked_130(i, colStart:end) = NaN;
%         masked_200(i, colStart:end) = NaN;
%         masked_455(i, colStart:end) = NaN;
% 
%     end
% end

% obtain bottom depth by dive
nDives = length(Dive);
endDive = zeros(nDives, 1);
bottomDepth = zeros(nDives, 1);

for i = 1:nDives
    endDive(i) = Dive(i).Index(2) - 1;
    bottomDepth(i) = Output(1).Depth(endDive(i));
end

%% Plot median Sv for all frequencies
figure(1)
clf

freqLabels = {'130 kHz', '200 kHz', '455 kHz', '769 kHz'};
Sv_all = {Sv_130, Sv_200, Sv_455, Sv_769};
caxisVals = [-110 -60];

for i = 1:4
    subplot(2,2,i)
    imagesc(Sv_all{i}', 'AlphaData', ~isnan(Sv_all{i}'))
    colormap('jet')
    caxis(caxisVals)
    ylim([0 105])
    xlabel('Ping Number')
    ylabel('Depth (m)')
    title(freqLabels{i})
    
    hold on
    plot(1:length(bottomDepth), bottomDepth, 'k-', 'LineWidth', 1, 'Color', [0 0 0 0.3])
    hold off
end

% Shared colorbar
h = colorbar;
ylabel(h, 'Volume Backscatter (dB re 1 m^{-1})')
h.Position(4) = 0.65;
h.Position(1) = .94 - h.Position(3);
h.Position(2) = 0.5 - h.Position(4)/2;

% save the figure
filename = strcat("C:/Users/Andrea/Documents/AMesquita2025/UNB/dataAnalysis/preyData/processedAZFP/updatedCode/2023/entireMission/medianSv2023_8.png");
print(gcf,'-dpng',filename,'-r0')

clear filename;
%close

%% Plot dB differences for all frequencies
figure(2)
clf

diffLabels = {'200-130 kHz', '455-200 kHz', '769-455 kHz'};
dbDiff_all = {Sv_200_130, Sv_455_200, Sv_769_400};
caxisVals = [3 9]

for i = 1:3
    subplot(2,2,i)
    imagesc(dbDiff_all{i}', 'AlphaData', ~isnan(dbDiff_all{i}'))
    colormap('jet')
    caxis(caxisVals)
    xlabel('Ping Number')
    ylabel('Depth (m)')
    title(diffLabels{i})
    
%     hold on
%     plot(1:length(bottomDepth), bottomDepth, 'k-', 'LineWidth', 2)
%     hold off
end

% Shared colorbar
h = colorbar;
ylabel(h, 'dB Difference')
h.Position(4) = 0.65;
h.Position(1) = .94 - h.Position(3);
h.Position(2) = 0.5 - h.Position(4)/2;

% save the figure
filename = strcat("C:/Users/Andrea/Documents/AMesquita2025/UNB/dataAnalysis/preyData/processedAZFP/updatedCode/2023/entireMission/dbDiff2023_8.png");
print(gcf,'-dpng',filename,'-r0')

clear filename;
%close

%% Plot masked Sv for all frequencies
figure(3)
clf

freqLabels = {'130 kHz', '200 kHz', '455 kHz', '769 kHz'};
Sv_all = {masked_130, masked_200, masked_455, masked_769};
%caxisVals = [-110 -60];

for i = 1:4
    subplot(2,2,i)
    imagesc(Sv_all{i}', 'AlphaData', ~isnan(Sv_all{i}'))
    colormap('jet')
    %caxis(caxisVals)
    ylim([0 105])
    xlabel('Ping Number')
    ylabel('Depth (m)')
    title(freqLabels{i})
    
%     hold on
%     plot(1:length(bottomDepth), bottomDepth, 'k-', 'LineWidth', 2)
%     hold off
end

% Shared colorbar
h = colorbar;
ylabel(h, 'Volume Backscatter (dB re 1 m^{-1})')
h.Position(4) = 0.65;
h.Position(1) = .94 - h.Position(3);
h.Position(2) = 0.5 - h.Position(4)/2;

% save the figure
filename = strcat("C:/Users/Andrea/Documents/AMesquita2025/UNB/dataAnalysis/preyData/processedAZFP/updatedCode/2023/entireMission/mMasked2023_8.png");
print(gcf,'-dpng',filename,'-r0')

clear filename;
%close

%% save variables

filename = strcat("C:/Users/Andrea/Documents/AMesquita2025/UNB/dataAnalysis/preyData/processedAZFP/updatedCode/2023/entireMission/","2023_8_Dive.mat");
save(filename,'Dive','Sv_130','Sv_200','Sv_455','Sv_769','Sv_200_130','Sv_455_200','Sv_769_400','masked_130','masked_200','masked_455','masked_769','StartDiveTime','EndDiveTime','bottomDepth','-v7.3');

%% calculate numerical density (ind. per m^3) from merged Dive structures

sigma_bs = [1.3e-11, 7.6e-11, 7.9e-11]; % for 200kHz, 455kHz, 769kHz

n = length(Dive);

for ii = 1:n
    Dive(ii).P(2).N = Dive(ii).P(2).masked / sigma_bs(1);  % 200 kHz
    Dive(ii).P(3).N = Dive(ii).P(3).masked / sigma_bs(2);  % 455 kHz
    Dive(ii).P(4).N = Dive(ii).P(4).masked / sigma_bs(3);  % 769 kHz
    
    Dive(ii).P(2).mN = nanmedian(Dive(ii).P(2).N);
    Dive(ii).P(3).mN = nanmedian(Dive(ii).P(3).N);
    Dive(ii).P(4).mN = nanmedian(Dive(ii).P(4).N);
end

%% scale density values by volume to estimate abundance


%% estimate biomass by incorporating mean organism weight


%% estimate energy density by incorporating kJ per gram of lipid


%% Plot numeric abundances for all frequencies
%Approximate civil twilight in July 2024: 7AM-8PM (day), 11PM-4AM (night)

%Numeric abundances were calculated from linearized masked Sv values divided
%by corresponding sigma_bs and averaged by dive profile
%Plot day and night profiles by depth

for i = 1:length(Dive)
    dt = datetime(Dive(i).starttime, 'ConvertFrom', 'datenum'); %convert time
    Dive(i).localtime = dt - hours(3); %convert to local time
end

for i = 1:length(Dive)
    hr = hour(Dive(i).localtime);

    if hr >= 7 && hr <= 20
        Dive(i).tod = "Day";
    elseif hr >= 23 || hr <= 4
        Dive(i).tod = "Night";
    else
        Dive(i).tod = "Other";
    end
end

depths = 1:105;
freqLabels = {'200 kHz', '455 kHz', '769 kHz'};
P_indices = [2, 3, 4];

figure('Position', [100 100 1200 900])

for f = 1:3
    j = P_indices(f);

    dayProfiles = [];
    nightProfiles = [];

    for i = 1:length(Dive)
            profile = Dive(i).P(j).mN(:);
            if strcmpi(Dive(i).tod, 'Day')
                dayProfiles = [dayProfiles, profile];
            elseif strcmpi(Dive(i).tod, 'Night')
                nightProfiles = [nightProfiles, profile];
            end
    end

    allVals = [dayProfiles(:); nightProfiles(:)];
    clim = [nanmin(allVals), nanmax(allVals)];

    % Day
    subplot(3, 2, (f-1)*2 + 1)
    if ~isempty(dayProfiles)
        imagesc(dayProfiles)
        set(gca, 'YDir', 'reverse')
        yticks(10:10:105)
        yticklabels(string(10:10:105))
        xlabel('Dive Profile')
        ylabel('Depth (m)')
        title(['Daytime - ' freqLabels{f}])
        caxis(clim)
        colormap(hot)
        colorbar
    else
        text(0.5, 0.5, 'No day data', 'HorizontalAlignment', 'center')
        axis off
    end

    % Night
    subplot(3, 2, (f-1)*2 + 2)
    if ~isempty(nightProfiles)
        imagesc(nightProfiles)
        set(gca, 'YDir', 'reverse')
        yticks(10:10:105)
        yticklabels(string(10:10:105))
        xlabel('Dive Profile')
        ylabel('Depth (m)')
        title(['Nighttime - ' freqLabels{f}])
        caxis(clim)
        colormap(hot)
        colorbar
    else
        text(0.5, 0.5, 'No night data', 'HorizontalAlignment', 'center')
        axis off
    end
end

figure('Position', [100 100 1200 900])

for f = 1:3
    j = P_indices(f);

    dayProfiles = [];
    nightProfiles = [];

    for i = 1:length(Dive)
        profile = Dive(i).P(j).mN(:);
        if strcmpi(Dive(i).tod, 'Day')
            dayProfiles = [dayProfiles, profile];
        elseif strcmpi(Dive(i).tod, 'Night')
            nightProfiles = [nightProfiles, profile];
        end
    end

    allVals = [dayProfiles(:); nightProfiles(:)];
    clim = [nanmin(allVals), min(nanmax(allVals), 1e4)];

    % Day
    subplot(3, 2, (f-1)*2 + 1)
    if ~isempty(dayProfiles)
        imagesc(dayProfiles)
        set(gca, 'YDir', 'reverse')
        yticks(10:10:105)
        yticklabels(string(10:10:105))
        xlabel('Dive Profile')
        ylabel('Depth (m)')
        title(['Daytime - ' freqLabels{f}])
        caxis(clim)
        colormap(hot)
        colorbar
    else
        text(0.5, 0.5, 'No day data', 'HorizontalAlignment', 'center')
        axis off
    end

    % Night
    subplot(3, 2, (f-1)*2 + 2)
    if ~isempty(nightProfiles)
        imagesc(nightProfiles)
        set(gca, 'YDir', 'reverse')
        yticks(10:10:105)
        yticklabels(string(10:10:105))
        xlabel('Dive Profile')
        ylabel('Depth (m)')
        title(['Nighttime - ' freqLabels{f}])
        caxis(clim)
        colormap(hot)
        colorbar
    else
        text(0.5, 0.5, 'No night data', 'HorizontalAlignment', 'center')
        axis off
    end
end

figure('Position', [100 100 1200 900]);

for f = 1:3
    j = P_indices(f);
    allProfiles = [];
    todLabels = [];
    diveIDs = [];

    for i = 1:length(Dive)
        profile = Dive(i).P(j).mN(:);
        allProfiles = [allProfiles, profile];
        todLabels = [todLabels, string(Dive(i).tod)];
        diveIDs = [diveIDs, i];
    end

    clim = [0, 10000];
    normVals = (allProfiles - clim(1)) / (clim(2) - clim(1));
    normVals = min(max(normVals, 0), 1);

    hotMap = hot(256);
    boneMap = bone(256);

    idxVals = round(normVals * 255) + 1;
    [rows, cols] = size(allProfiles);
    RGB = ones(rows, cols, 3);

    for col = 1:cols
        if strcmpi(todLabels(col), 'Day')
            cmap = hotMap;
        else
            cmap = boneMap;
        end
        for ch = 1:3
            RGB(:, col, ch) = cmap(idxVals(:, col), ch);
        end
    end

    ax = subplot(3,1,f);
    image(RGB)
    set(gca, 'YDir', 'reverse')
    yticks(10:10:105)
    yticklabels(string(10:10:105))
    ylabel('Depth (m)')
    xlabel('Dive Profile')
    title(freqLabels{f})

    tickStep = max(1, floor(cols / 10));
    xtickIdx = 1:tickStep:cols;
    xtickLabels = diveIDs(xtickIdx);
    xticks(xtickIdx)
    xticklabels(xtickLabels)

    axPos = get(ax, 'Position');
    cbHot = colorbar('Position', [axPos(1) - 0.05, axPos(2), 0.01, axPos(4)]);
    colormap(cbHot, hotMap);
    cbHot.Ticks = linspace(0, 1, 5);
    cbHot.TickLabels = arrayfun(@(x) sprintf('%.0f', clim(1) + x * (clim(2) - clim(1))), cbHot.Ticks, 'UniformOutput', false);
    cbHot.Label.String = 'Daytime';

    cbBone = colorbar('Position', [axPos(1) + axPos(3) + 0.01, axPos(2), 0.01, axPos(4)]);
    colormap(cbBone, boneMap);
    cbBone.Ticks = linspace(0, 1, 5);
    cbBone.TickLabels = arrayfun(@(x) sprintf('%.0f', clim(1) + x * (clim(2) - clim(1))), cbBone.Ticks, 'UniformOutput', false);
    cbBone.Label.String = 'Nighttime';
end

figure;
tiledlayout(2,2, 'Padding', 'compact', 'TileSpacing', 'compact')

for f = 1:3
    j = P_indices(f);
    dayMeans = [];
    nightMeans = [];
    
    for i = 1:length(Dive)
            profile = Dive(i).P(j).mN(:);
            meanVal = mean(profile, 'omitnan');
            if strcmpi(Dive(i).tod, 'Day')
                dayMeans(end+1) = meanVal;
            elseif strcmpi(Dive(i).tod, 'Night')
                nightMeans(end+1) = meanVal;
            end
    end
    
    nexttile
    hold on
    
    boxplot([dayMeans, nightMeans], ...
        [repmat({'Day'}, 1, length(dayMeans)), repmat({'Night'}, 1, length(nightMeans))], ...
        'Colors', 'k', 'Symbol', '')
    
    xDay = ones(size(dayMeans)) + 0.1*randn(size(dayMeans));
    xNight = 2*ones(size(nightMeans)) + 0.1*randn(size(nightMeans));
    scatter(xDay, dayMeans, 30, [0.6, 0.8, 1], 'filled', 'MarkerFaceAlpha', 0.6)
    scatter(xNight, nightMeans, 30, [0, 0, 0.5], 'filled', 'MarkerFaceAlpha', 0.6)
    
    ylim([0 10000])
    
    set(gca, 'XTickLabel', {'Day', 'Night'})
    ylabel('Mean mN value')
    title(freqLabels{f})
    hold off
end

nexttile
axis off
legend({'Day points', 'Night points'}, 'Location', 'best')

% save the figure
%filename = strcat("C:/Users/Andrea/Documents/AMesquita2025/UNB/dataAnalysis/preyData/processedAZFP/updatedCode/2024/mMasked2024_1_4.png");
%print(gcf,'-dpng',filename,'-r0')

%clear filename;
%close

%%  Test Plots
% Test plot data by profile
% figure(1)
% 
% subplot(2,1,1)
% imagesc([NaN * ones(5, size(P(1).avg_sv, 1)); 10*log10(abs(P(1).avg_sv'))],'AlphaData',~isnan([NaN * ones(5, size(P(1).avg_sv, 1)); 10*log10(abs(P(1).avg_sv'))])) % conversion back to decibels + dealing with the fact that we cut off the first 5 m of data
% colormap('jet');
% caxis([-100 -70]);
% % set(gca, 'Xdir', 'reverse');
% xlabel('Time')
% ylabel('Depth (m)')
% title('130 kHz')
% xt = get(gca,'XTick');
% xtlbl = [];
% for i = 1:numel(xt)
%     temp = Output(1).Date(xt(i));
%     temp = datetime(temp, 'ConvertFrom','datenum','Format','HH:mm');
%     temp = char(temp);
%     xtlbl = [xtlbl;temp];
% end
% 
% set(gca, 'XTick',xt, 'XTickLabel',xtlbl, 'XTickLabelRotation',30)
% hold on
% %line(1:length(bott_dep2),bott_dep2(1,1:length(bott_dep2)),'Color','r','LineWidth',1)
% hold off
% colorbar
% 
% subplot(2,1,2)
% imagesc([NaN * ones(5, size(P(2).avg_sv, 1)); 10*log10(abs(P(2).avg_sv'))],'AlphaData',~isnan([NaN * ones(5, size(P(2).avg_sv, 1)); 10*log10(abs(P(2).avg_sv'))]))
% colormap('jet');
% caxis([-110 -40]);
% % set(gca, 'Xdir', 'reverse');
% xlabel('Ping Number')
% ylabel('Depth (m)')
% ylim([0,100])
% title('200 kHz')
% set(gca, 'XTick',xt, 'XTickLabel',xtlbl, 'XTickLabelRotation',30)
% hold on
% %line(1:length(bott_dep2),bott_dep2(2,1:length(bott_dep2)),'Color','r','LineWidth',1)
% hold off
% colorbar
% 
% subplot(2,2,3)
% imagesc([NaN * ones(5, size(P(3).avg_sv, 1)); 10*log10(abs(P(3).avg_sv'))],'AlphaData',~isnan([NaN * ones(5, size(P(3).avg_sv, 1)); 10*log10(abs(P(3).avg_sv'))])) 
% colormap('jet');
% caxis([-80 -40]);
% % set(gca, 'Xdir', 'reverse');
% xlabel('Ping Number')
% ylabel('Depth (m)')
% ylim([0,100])
% title('455 kHz')
% set(gca, 'XTick',xt, 'XTickLabel',xtlbl, 'XTickLabelRotation',30)
% hold on
% %line(1:length(bott_dep2),bott_dep2(3,1:length(bott_dep2)),'Color','r','LineWidth',1)
% hold off
% 
% subplot(2,2,4)
% imagesc([NaN * ones(5, size(P(4).avg_sv, 1)); 10*log10(abs(P(4).avg_sv'))],'AlphaData',~isnan([NaN * ones(5, size(P(4).avg_sv, 1)); 10*log10(abs(P(4).avg_sv'))]))
% caxis([-80 -40]);
% % set(gca, 'Xdir', 'reverse');
% xlabel('Ping Number')
% ylabel('Depth (m)')
% ylim([0,100])
% title('769 kHz')
% set(gca, 'XTick',xt, 'XTickLabel',xtlbl, 'XTickLabelRotation',30)
% hold on
% %line(1:length(bott_dep2),bott_dep2(4,1:length(bott_dep2)),'Color','r','LineWidth',1)
% hold off
% 
% % single colorbar for all four plots
% h = colorbar;
% set(get(h,'label'),'string','Sv (dB scattering per unit volume)');
% 
% % h.Position(4) = 0.65;
% % h.Position(1) = .94-h.Position(3);
% % h.Position(2) = 0.5-h.Position(4)/2;
% % 
% % AddLetters2Plots(gcf,'VShift',-0.04)
% % % save the figure
% % filename = strcat("/Users/dmossman/Box/2022 MSc Thesis Work/Visuals/MATLAB Echosounder Figures/",date,"Sept/Frequencies_All_",date,"Sept.png");
% % print(gcf,'-dpng',filename,'-r0')
% % 
% % clear filename;
% % %close
% 
% %Plot
% figure
% imagesc(Sv_455')
% p=colorbar
% ylabel(p,'Volume Backscatter at 769 kHz P2')
% caxis([-110 -60])
% ylim([0 100])
% colormap(jet)

%% Plot a subset of the data - Andréa added this section to QAQC AZFP data

% startTimes = datetime(StartDiveTime, 'ConvertFrom', 'datenum');
% 
% % Define periods as [month startDay]
% periods = [
%     7, 21;
%     8, 14;
%     9,  9
% ];
% 
% for p = 1:size(periods,1)
%     month = periods(p, 1);
%     startDay = periods(p, 2);
% 
%     figure
%     for d = 0:2
%         thisDay = datetime(2018, month, startDay + d);
%         dayMask = isbetween(startTimes, thisDay, thisDay + days(1));
%         Sv_day = Sv_455(dayMask, :);
% 
%         subplot(2,2,d+1)  % arrange as 2 rows x 2 columns
%         imagesc(Sv_day')
%         colorbar
%         ylabel('Depth (m)')
%         xlabel('Dive index (Ping #)')
%         title(['Sv at 455 kHz on ', datestr(thisDay, 'mmm dd')])
%         caxis([-110 -60])
%         ylim([0 100])
%         colormap(jet)
%     end
% 
%     % Add a title for the whole figure
%     sgtitle(['Sv at 455 kHz — ', datestr(datetime(2018, month, startDay), 'mmmm'), ...
%              ' ', num2str(startDay), '–', num2str(startDay+2)])
% end

%% extra plots
% %test plot the Sv by dive for the 130 kHz
% divedata=[Dive(1).P(1).sv];
% for ii=2:length(Dive)
%     divedata=[divedata;Dive(ii).P(1).sv];
% end;
% 
% figure(1)
% imagesc([NaN * ones(5, size(divedata, 1)); 10*log10(abs(divedata'))]) % conversion back to decibels + dealing with the fact that we cut off the first 5 m of data
% colormap('jet');
% caxis([-100 -40]);
% xlabel('Ping Number')
% ylabel('Depth (m)')
% title('130 kHz')
% colorbar
% 
% % plot single dives
% figure
% imagesc(10*log10(abs(Dive(6).P(1).sv))')
% colormap('jet')
% caxis([-80 -60]);
% ylim([0 150])

%% Subset 2023 data

% rowIdx = 142:365;
% 
% for n = 1:numel(Output)
%     fields = fieldnames(Output(n));
%     
%     for k = 1:numel(fields)
%         thisField = Output(n).(fields{k});
%         
%         if isnumeric(thisField) && size(thisField,1) >= max(rowIdx)
%             Output(n).(fields{k}) = thisField(rowIdx,:);
%         end
%     end
% end
% 
% removeIdx = 144:364;
% 
% for n = 1:numel(Output)
%     fields = fieldnames(Output(n));
% 
%     for k = 1:numel(fields)
%         thisField = Output(n).(fields{k});
% 
%         if isnumeric(thisField) || isdatetime(thisField) || iscell(thisField)
%             if size(thisField,1) >= max(removeIdx)
%                 keepIdx = setdiff(1:size(thisField,1), removeIdx);
%                 Output(n).(fields{k}) = thisField(keepIdx, :);
%             end
%         end
%     end
% end